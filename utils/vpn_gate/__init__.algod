CLASS VpnGateData :=
    CONST N_COLS AS Integer,
    header AS Tuple<N_COLS TIMES String>,
    data AS List<Tuple<N_COLS TIMES String>>,

    METHOD NEW(n_col AS Integer) :=
        this.N_COLS <- n_col
    ENDMETHOD
ENDCLASS


FUNCTION ParseVpnGateData(text AS String) -> VpnGateData :=
    lines AS Tuple<String...> <- DO {{remove leading and trailing
        whitespace from @text & split it around newline characters}}
    // Identifying star- and hash-started line indices...
    starIndices AS Set<Integer>, hashIndices AS Set<Integer> <- DO {{go
        over the lines and find those starts with `*` or `#` and return
        their indices separately as sets of integers}}
    DO {{remove leading & trailing star-started lines (comments) based on
        @starIndices & update both @starIndices and @hashIndices sets
        accordingly}}
    IF starIndices IS NOT EMPTY THEN
        RAISE {{format error: comments (start-started lines) found in
            the middle}}
    ENDIF
    IF hashIndices != {0} THEN
        RAISE {{format error: unsupported header position: @hashIndices}}
    ENDIF
    // Removing the leading '#' from the header...
    lines[0] = lines[0][1:]  
    // 
    header AS Tuple<String...> <- DO {{parse @lines[0] as CSV}}
    nCols AS Integer <- LENGTH OF header
    vpnGateData AS VpnGateData <- NEW VpnGateData(nCols)
    vpnGateData.header <- header
    // Parsing the rest of lines...
    nRowCols AS Integer
    record AS Tuple<nCols TIMES String>
    dataRows AS Tuple<Tuple<String...>...> <- DO {{parse @lines[1 .. ]
        as CSV}}
    FOR EACH row IN dataRows DO
        nRowCols <- LENGTH OF row
        diff AS Integer <- nCols - nRowCols
        IF diff < 0 THEN
            RAISE {{format error: inconsistent column numbers}}
        ELSE IF diff > 0 THEN
            record <- dataLine + Tuple(diff TIMES "")
        ELSE
            record <- dataLine
        ENDIF
        DO {{append @record to @vpnGateData.data}}
    ENDFOR
    RETURN vpnGateData
ENDFUNCTION